{
    "input": [
        "Generate the code prompt for the last task using the similar style of the example codes. Add enough print() functions following the provided steps  in the provided explanation to output intermediate reasoning steps towards the answer and keep track of important variables. Implement the code prompt as much as you can and describe the logic in code following the provided explanation but do not make a code that is biased toward a single task example instance. For example, do not use hard-coded variables that are obtained from task instances (e.g., using specific name of person in the question). The code prompt must be able to be applied to various instances of same task. When returning the final answer, carefully consider the output format. Especially, for the multiple choice questions, the final answer should be one of the given options. The main function name should be 'evaluate_boolean_word_problem'. Along with the main function, you may want to define some helper functions that might be helpful for implementing the 'evaluate_boolean_word_problem'. But you don't have to explicitly implement the helper functions, but just define them with function name and a single-line explanation in comment. When constructing the main function, actively use 'if else statement' to take different reasoning paths based on the condition, 'loop' to efficiently process the repititive instructions, 'dictionary' to keep track of connections between important variables. These will make your code more logical and effective.",
        "",
        "[Example 1]",
        "Example task instances:",
        "If you follow these instructions, do you return to the starting point? Always face forward. Take 2 steps forward. Take 2 steps backward.",
        "Options:",
        "- Yes",
        "- No",
        "",
        "If you follow these instructions, do you return to the starting point? Take 8 steps. Take 5 steps. Take 5 steps. Take 10 steps. Take 5 steps.",
        "Options:",
        "- Yes",
        "- No",
        "",
        "If you follow these instructions, do you return to the starting point? Take 6 steps. Take 2 steps. Take 2 steps. Turn left. Take 5 steps. Take 8 steps. Turn around.",
        "Options:",
        "- Yes",
        "- No",
        "",
        "Output Format:",
        "'Yes' or 'No'\\Explanation:",
        "This task involves determining whether a series of movements brings a person back to their starting point. This requires tracking the person's position in a two-dimensional space and updating their location based on the instructions given.",
        "",
        "Analyzing the Task:",
        "",
        "1.Directional Movement and Position Tracking: The task requires keeping track of the person's position (x and y coordinates) as they move in different directions.",
        "",
        "2.Interpreting Movement Instructions: Instructions include steps in various directions (left, right, forward, backward) and turning, which affects the direction of subsequent steps.",
        "",
        "3.Determining the Final Position: The objective is to determine if the final position after following all instructions is the same as the starting position.",
        "",
        "Constructing the Code Prompt:",
        "",
        "1.Initializing Position and Direction: The person starts at a fixed point (0,0) facing a specific direction (e.g., north). This setup requires initializing variables for x and y coordinates, and a variable for direction.",
        "",
        "2.Parsing Instructions: The instructions are separated and parsed to identify the type and magnitude of each movement. This involves string manipulation and possibly a mapping of textual instructions to movements and turns.",
        "",
        "3.[Important] Processing Each Instruction: Each instruction affects the position or the direction of movement. The intermediate step for calculating the final coordinate should be printed out using print() function. This involves:",
        "",
        "-Translating forward, backward, left, and right steps into changes in the x and y coordinates.",
        "-Handling turns to update the direction of movement.",
        "-A function like process_instruction can be created to encapsulate the logic for each instruction.",
        "4.Checking the Final Position: After processing all instructions, the final coordinates are compared with the starting point to determine if the person has returned to the start.",
        "",
        "5.Returning the Result: Based on whether the final position matches the starting point, the function returns 'Yes' or 'No'.",
        "",
        "Code prompt:",
        "def ends_up_at_start(input_text):",
        "    # Step 1: Initialize coordinates and direction by setting the starting point at (0, 0) and face north.",
        "    cur_x, cur_y = 0, 0",
        "    cur_direction = 0",
        "",
        "    # Step 2: Identify and list up instructions from the input text.",
        "    instructions = input_text.split('. ')",
        "    ",
        "    # Step 3: Process each instruction and update the current coordinates and direction. In order to keep track of changes, output the instruction, current and updated coordinates and direction.",
        "    for i, instruction in enumerate(instructions):",
        "        new_x, new_y, new_direction = process_instruction(instruction, cur_x, cur_y, cur_direction) # process instruction to calculate new position and direction",
        "        print(f\"Step {i}: {instruction} - current coordinates: ({cur_x}, {cur_y}), current direction: {cur_direction} -> updated coordinates: ({new_x}, {new_y}), updated direction: {new_direction}\")",
        "        cur_x, cur_y, cur_direction = new_x, new_y, new_direction # update position and direction",
        "",
        "    # Step 4: Output \"yes\" if the final coordinates are (0, 0). Otherwise, output \"no\" as the final answer.",
        "    return 'yes' if cur_x == 0 and cur_y == 0 else 'no'",
        "",
        "[Example 2]",
        "Example task instances:",
        "Today, Anthony went to the bakery. Between what times could they have gone?",
        "We know that:",
        "Anthony woke up at 6am.",
        "John saw Anthony working out at the gym from 6am to 10am.",
        "Jennifer saw Anthony walking towards the Statue of Liberty from 10am to 12pm.",
        "Sarah saw Anthony buying lunch at the deli from 12pm to 1pm.",
        "Andrew saw Anthony buying a bike at the bike shop from 3pm to 5pm.",
        "The bakery was closed after 5pm.",
        "Between what times could Anthony have gone to the bakery?",
        "Options:",
        "(A) 1pm to 3pm",
        "(B) 10am to 12pm",
        "(C) 12pm to 1pm",
        "(D) 3pm to 5pm",
        "",
        "Today, Andrew went to the park. Between what times could they have gone?",
        "We know that:",
        "Andrew woke up at 6am.",
        "David saw Andrew stretching at a yoga studio from 6am to 7am.",
        "Leslie saw Andrew buying lunch at the deli from 7am to 9am.",
        "James saw Andrew waiting at the train station from 9am to 12pm.",
        "Tiffany saw Andrew working at the office from 12pm to 3pm.",
        "Mark saw Andrew waiting at the airport from 3pm to 7pm.",
        "The park was closed after 10pm.",
        "Between what times could Andrew have gone to the park?",
        "Options:",
        "(A) 6am to 7am",
        "(B) 9am to 12pm",
        "(C) 7pm to 10pm",
        "(D) 7am to 9am",
        "",
        "Today, Michael went to the park. Between what times could they have gone?",
        "We know that:",
        "Michael woke up at 7am.",
        "William saw Michael playing tennis at the tennis court from 7am to 8am.",
        "Richard saw Michael working at the office from 1pm to 3pm.",
        "Emily saw Michael buying lunch at the deli from 3pm to 8pm.",
        "Mark saw Michael walking towards the Statue of Liberty from 8pm to 10pm.",
        "The park was closed after 10pm.",
        "Between what times could Michael have gone to the park?",
        "Options:",
        "(A) 3pm to 8pm",
        "(B) 8am to 1pm",
        "(C) 7am to 8am",
        "(D) 8pm to 10pm",
        "",
        "Output Format:",
        "'(A)', '(B)', '(C)', ...\\Explanation:",
        "The task involves determining the time slots when individuals could have performed a specific activity, based on a series of observations that define where they were seen at various times throughout the day. This requires logical reasoning to deduce the only time slot where the individual was unaccounted for and thus could have performed the said activity.",
        "",
        "Analyzing the Task:",
        "1.Sequential Events and Time Slots: Each example consists of sequential events occurring at different times. The goal is to find a time slot not occupied by any known activity.",
        "",
        "2.Identifying Time Intervals: The time intervals during which each activity occurred are crucial. We need to understand and process these intervals to figure out the free slot.",
        "",
        "3.Eliminating Occupied Time Slots: By systematically ruling out the time slots during which the person was seen engaging in other activities, we can identify the potential free slot.",
        "",
        "Constructing the Code Prompt:",
        "1.Breaking Down the Input: The first step involves parsing the input text to separate the statements about activities and the time options. This involves string manipulation to extract relevant parts of the text.",
        "",
        "2.Identifying Time Constraints: The start and end of possible times for the unaccounted activity (e.g., the time when the person woke up and the time by which the location of interest was closed) need to be identified. This helps in setting the boundaries for our search.",
        "",
        "3.Initializing an Available Time Map: To keep track of which time slots are occupied and which are free, an available time map (a dictionary in Python) is initialized with time slots marked as 'free' initially. This map will be updated as more information is processed.",
        "",
        "4.Processing Each Statement: For each activity mentioned in the statements, the corresponding time span needs to be marked as 'occupied' in the available time map. While iterating over the statements, process each statement and update the time map. Note that time map should be printed out at each step to logging the results. This involves:",
        " - Extracting time information from each statement (using a function like extract_information).",
        " - Updating the available time map accordingly.",
        "5. Determining the Free Time Slot: After all statements are processed, the time slot that remains marked as 'free' in the map is the one where the individual could have performed the activity in question.",
        "",
        "6. Matching with Provided Options: Finally, the free time slot is matched against the provided options to identify the correct answer.",
        "",
        "Code prompt:",
        "def solve_temporal_sequences_quiz(input_text):",
        "    # Step 1: Identify statements and options from the input_text and output the statements.",
        "    statement_text, option_text = input_text.split(\"\\nOptions:\\n\")",
        "    parts = statement_text.split(\"\\n\")",
        "    statements = parts[1:-2]",
        "    options = option_text.split(\"\\n\")",
        "    print(\"Statements:\", statements)",
        "",
        "    # Step 2: Check the start and end of the possible time.",
        "    print(\"Start of the possible time: \", parts[0])",
        "    print(\"End of the possible time: \", parts[-2])",
        "    ",
        "    # Step 3: Initialize an available time map with the time slots in the options and output it. The time slots are marked as 'free' initially.",
        "    available_time_map = {option[4:]: \"free\" for option in options}",
        "    print(f\"Initial available time dictionary: {available_time_map}\")",
        "",
        "    # Step 4: Sequentially go through each statement, marking the times when the individual was seen or known to be engaged in specific activities. In this step, you should generate the target time slots and the updated available time map according to the statement.",
        "    for i, statement in enumerate(statements):",
        "        event, time_span = extract_information(statement)",
        "        print(f\"\\nStep {i}: {statement}\")",
        "        print(f\"current time occupation: {available_time_map}\")",
        "        print(f\"Time span to be occupied: {time_span}\")",
        "        available_time_map[time_span] = \"not available\"",
        "        print(f\"updated time occupation: {available_time_map}\")",
        "",
        "    # Step 5: By checking the available time map, identify which time slot is marked as 'free'. For each time slot, output the time slot is free or not available.",
        "    for key in available_time_map:",
        "        if available_time_map[key] == \"free\":",
        "            print(f\"{key} is free.\")",
        "            free_time = key",
        "        else:",
        "            print(f\"{key} is not available.\")",
        "    # Step 6: Review the provided options and return the one that matches the identified free time slot in Step 5.",
        "    print(f\"Options:\\n{option_text}\")",
        "    for option in options:",
        "        if free_time in option:",
        "            return option",
        "",
        "[Example 3]",
        "Example task instances:",
        "I have a trumpet, a drum, a piano, a flute, and two trombones. How many musical instruments do I have?",
        "",
        "I have a potato, a cabbage, a cauliflower, a duck, an onion, a lettuce head, a garlic, a bear, a head of broccoli, a carrot, a chicken, and three yams. How many vegetables do I have?",
        "",
        "I have three oranges, a pig, a frog, a cow, three bananas, a nectarine, and a snail. How many animals do I have?",
        "",
        "Output Format:",
        "A positive integer\\Explanation:",
        "Explanation:",
        "This task involves identifying and counting specific types of objects (fruits or vegetables) from a mixed list. The primary challenge is correctly categorizing each item in the list and then tallying the counts of the desired categories.",
        "",
        "Analyzing the Task:",
        "1. Object Categorization: Determining whether each item in the list is a fruit, a vegetable, or neither. This requires knowledge of common fruits and vegetables.",
        "",
        "2. Counting Objects: Accurately counting the number of items in each category. This may involve handling singular and plural forms, as well as numerical phrases (e.g., \"two peaches\").",
        "",
        "3. Handling Varied Input: The input text may vary in format and content, requiring flexible parsing to extract the necessary information.",
        "",
        "Constructing the Code Prompt:",
        "1. Extracting Objects from Input: The first step is parsing the input text to create a list of objects. This requires string manipulation and possibly natural language processing techniques.",
        "",
        "2. Extracting the Question: Determine what category of items needs to be counted (e.g., fruits, vegetables) from the input text. ",
        "",
        "3. Initializing Count Variables: Set up a variable to keep track of the total count of the desired objects.",
        "",
        "4. [Important] Counting Each Object: Iterate over each object, determine if it belongs to the desired category (fruit or vegetable), and count it. Intermeditate count results shoud be logged with print() function. This involves:",
        "   - Identifying singular and plural forms.",
        "   - Recognizing and handling numerical phrases.",
        "   - Keeping a running total of the count.",
        "",
        "5. Returning the Total Count: After processing all objects, return the total count as the answer.",
        "",
        "Code prompt:",
        "def count_objects(input_text):",
        "    # Step 1: Identify and list all objects and their number from the input text. Output the listed objects.",
        "    objects_list = extract_objects(input_text)",
        "    print(\"All objects:\", objects_list)",
        "",
        "    # Step 2: Identify and show the specific question asked from the input text.",
        "    qustion = extract_question(input_text)",
        "    print(\"question:\", question)",
        "",
        "    # Step 3: Initialize the total count by setting it to 0.",
        "    total_count = 0",
        "",
        "    # Step 4: Go through each object in the list in steps, count the object according to the question, adds up the object's count to the total count, and show the count and intermediate count.",
        "    for i, object in enumerate(objects_list):",
        "        single_object_count = count_single_object(object)",
        "        total_count += single_object_count",
        "        print(f\"Step ({i}) - {object}: {single_object_count}, Intermediate count: {total_count}\")",
        "",
        "    # Step 5: Output the final number. After going through all objects, output the total number as the answer to the question.",
        "    return total_count",
        "",
        "[Example 4]",
        "Example task instances:",
        "Question: Elanor lies. Dallas says Elanor tells the truth. Fletcher says Dallas lies. Jamey says Fletcher tells the truth. Delfina says Jamey lies. Does Delfina tell the truth?",
        "",
        "Question: Amberly lies. Shenna says Amberly tells the truth. Willian says Shenna tells the truth. Raymond says Willian lies. Sal says Raymond lies. Does Sal tell the truth?",
        "",
        "Question: Kandi tells the truth. Alejandro says Kandi tells the truth. Millicent says Alejandro lies. Shalonda says Millicent lies. Conception says Shalonda lies. Does Conception tell the truth?",
        "",
        "Output Format:",
        "'Yes' or 'No'\\Explanation:",
        "Explanation:",
        "This task involves determining the truthfulness of a statement made by one individual based on the statements made by others in a chain. The task requires understanding the relationships between truth-tellers and liars and applying logical reasoning to determine the final answer.",
        "",
        "Analyzing the Task:",
        "1. Establishing Truth Relationships: Each person's statement about another person can be categorized as either true or false. This forms the basis of determining who tells the truth and who lies.",
        "",
        "2. Propagating Truthfulness: By analyzing the statements in a sequential manner, the truthfulness of each person can be deduced based on the statements made by others.",
        "",
        "3. Identifying the Final Question: The task usually asks whether a specific person tells the truth or not based on the chain of statements.",
        "",
        "Constructing the Code Prompt:",
        "1. Parsing Statements: Extract the statements made by each person from the input text. This involves identifying who is talking about whom and whether they are telling the truth or lying.",
        "",
        "2. Establishing Truth Relationships: Create a dictionary to store the truthfulness of each person based on the statements made by others. This dictionary will be updated as the statements are processed.",
        "",
        "3. [Important] Analyzing Statements: Iterate over each statement and update the truthfulness of the individuals involved based on the logic that if A says B lies, then A is telling the truth if B is a liar, and vice versa. This step involves logical reasoning and updating the truth dictionary.",
        "",
        "4. Extracting the Final Question: Identify the specific question asked in the input text regarding the truthfulness of a particular person.",
        "",
        "5. Determining the Answer: Based on the final truthfulness of the person in question as determined by the logic and the statements provided, select 'Yes' if the person tells the truth and 'No' if they do not.",
        "",
        "By following these steps and applying logical reasoning to the statements provided, the code can accurately determine whether the specified individual tells the truth or not.",
        "",
        "Code prompt:"
    ],
    "output": [
        [
            "def evaluate_boolean_word_problem(input_text):",
            "    # Step 1: Identify the statements and the question from the input text.",
            "    statements, question = input_text.split(\"?\")",
            "    statements = statements.split(\". \")",
            "    print(\"Statements:\", statements)",
            "    print(\"Question:\", question)",
            "",
            "    # Step 2: Initialize a truth dictionary to keep track of who tells the truth and who lies.",
            "    truth_dict = {}",
            "",
            "    # Step 3: Process each statement to update the truth dictionary based on the logic provided.",
            "    for statement in statements:",
            "        person1, action, person2 = statement.split(\" \")",
            "        if action == \"lies\":",
            "            truth_dict[person1] = not truth_dict[person2]",
            "        else:",
            "            truth_dict[person1] = truth_dict[person2]",
            "        print(f\"{person1} says {person2} {action}. {person1} tells the truth: {truth_dict[person1]}\")",
            "",
            "    # Step 4: Determine the truthfulness of the person in question based on the truth dictionary.",
            "    person_to_check = question.split(\" \")[-2]",
            "    answer = 'Yes' if truth_dict[person_to_check] else 'No'",
            "    ",
            "    return answer"
        ]
    ]
}